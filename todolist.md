// - Ставить капчи на фронтеэнде. Ставить проверки на количество запросов на бэкенде через кеш.

БЭКЕНД бэклог:
// - Postgresql url - посмотреть все параметры.
// Postgresql сделать максимальное время коннекшна. https://www.postgresql.org/docs/current/runtime-config-client.html
// Postgresql политика доступа. В приложении дать права только на чтение и запись.

// core affinity - нужно ли это.

// - TLS, Connection Pool for Lettre.

// - Hyper TCP/HTTp connection pool. Есть ли коннекшн пул Тсп на сервере?

// - Понять, сколько Коннекшноы для Бд должно быть в пуулле в инстансе приложения.

// - При продакшне проверить, везде ли расставлены тлс и нужно ли это

// - При выходе в продакшн поставить защиту от флуда. Чтобы пользователь не мог сделать миллион публикаций, например. То есть, чтобы нам быстро не заполнили террабайты данных.

// - Http3 Quick.

// определять роботов или хакеров по тому, что они пытаются послать в запросе то, что им при Гет не могло прийти. То есть, если идет запрос с Юзера1 на апдейт юзера2, значит, либо своровали токен(но тогда бы обновляли Юзера1), либо Юзер1 пытается перебором прощупать защиту.

// - ставить капчи на фронтеэнде. Ставить проверки на количество запросов на бэкенде через кеш.

// - Ограничивать количество запросов с одного адреса на специфические урлы. (Например, отправка писем, и так далее)

// - Ограничить максимальный развмер данных во входящем запросе на апи. (Проверять длину Хедеров, проверять длину Тела)

// - Attack types (DDOS, for example)

// - Header Connection: Keep-alive - disable https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8/Connection

// - Сделать механизм изменения секьюрити кей (самый важное, что будет храниться на сервере) для всех токенов.

// - Подумать, какие поля в базе данных должны быть захешированы (закодированы) и нужно ли это/

// - Разобратьс с лимитами на сущность для другой сущности. Например, у юзера только 100 каналов подписанных, 300 диалогв, и тд и тп.

// - КАк удалять зваписи из AUDevice и нужно ли?. Те девайсы, которые уже не используются у пользователя. Как отследить, что используется за какой период, а что нет. Добавить параметр и обновлять при обновлении рефрешТокена? или же смотреть сразу в рефрештокене?

// - Проверять, сколько байт принимаем с запроса (Установить порог, чтобы нельзя было сделать переполнение оперативной памяти). Вообще, проверить вот что. Контент-Ленс установить маленький, но послать больше байт. Как http отреагирует вообще. https://docs.rs/hyper/0.14.24/hyper/body/fn.to_bytes.html посмотреть пример

// - Linux socket filtering with BPF нужно ли?

// - Обязательно сделать так, чтобы на каждый НАСТОЯЩИЙ POST (то есть, insert/update в БД) не нужно было проверять на наличие в бд пользователя, айди которого пришел в токене. (В простом варианте пользователя можно удалить, но токен для него останется валидным до экспирации). Нужно придумать механизм, который удаляет пользователя именно из бд ТОЧНО после того, как вышел срок экспирации. Например, помечать пользователя как удаленный, и не давать таким пользователям создавать аксесс токен, но удалять после.

// - Для регистрации добавить много защит. От скриптовой регистрации. От регистрации с одного телефона многих аккаунтов и подобныке ю


// !- ОБНОВИТЬ КРЕЙТЫ перед релизом. Понять, какие фичи нужны и везде ли нужны дефаулт-фичи.

// - проерить, везде ли UTC таймзона?

// СДелать механизм защиты от DDDos на кеше - для каждого апи разное количество допустимых запросов.

// opt-lvl=3 slower opt-level=2 https://doc.rust-lang.org/cargo/reference/profiles.html https://doc.rust-lang.org/rustc/profile-guided-optimization.html

// Проверить, что не нужно заново создавать коннекшн пул (то есть, не нужно заново перезапускать сервер), если Бд отключилась и потом включилась.

// Как синхронизировать время на серверах в распределенной системе? Нужно ли для моих задач (не требуется микроточности).Если нужнн один источник правды, то создать 1 сервер, отдающий время - есть ли смысл?

// ставить проверку от ДДОС. ЧТобы хакер не смог, например, сделать запрос на Подписку на канал множество раз подряд.



БЭКЕНД todo:
// Возможно ли не хранить Рефреш токен в Бд? Завязать его на Аксессе?  но как тогда делать разлогин на сервере принудительный?
// Или идти от обратного??? В Бд хранить только те токены, котоыре разлогинились принудительно, потому что принудительный разлогин делают намного меньше людей.
// cs.user__id = ${}   это можно написать в условие On Для JOIN, но можно и написать в условие WHERE. ПОнять, где его нужно написать, чтобы с самого начала в выборке для джоина было меньше строк.
// Регистрация, создание каналов ( и подобное) должно быть сделано через криптограыию ( нужно, чтобы была уверенность  в том, что запрос происходит не ботом, а через приложение с устройства).


// - Разбить код на микросервисы. Использовать Features, чтобы можно было, например, скомпилировать только работу с каналами, но не с токенами.
// !!!!!!!!!!!!!!! Проверять валидность байт в типе Стринг с клиента. Возможно, встроить в модуль.
// Настроить TCP:
     http2_builder = http2_builder
         .tcp_nodelay(environment_configuration.http_server.tcp.nodelay)
         .tcp_sleep_on_accept_errors(environment_configuration.http_server.tcp.sleep_on_accept_errors)
         .tcp_keepalive_retries(environment_configuration.http_server.tcp.keepalive.retries_quantity);
     http2_builder = match environment_configuration.http_server.tcp.keepalive.duration {
         Option::Some(duration) => http2_builder.tcp_keepalive(Option::Some(Duration::from_secs(duration))),
         Option::None => http2_builder.tcp_keepalive(Option::None),
     };
     http2_builder = match environment_configuration.http_server.tcp.keepalive.interval_duration {
         Option::Some(interval_duration) => http2_builder.tcp_keepalive_interval(Option::Some(Duration::from_secs(interval_duration))),
         Option::None => http2_builder.tcp_keepalive_interval(Option::None),
     };
// Hyper TCP/HTTp connection pool - ?

// сделать миграции как команду, чтобы можно было запускать из кода и не использовать сторонний сервис по типу Дизеля.
// Серилизация в Bytes сразу возможно ли ?
// проставить инлайнинг
// в Бд различать ConstraintException и недоступность базы данных.

// Составить требования для пароля.

// сделать так, чтобы нельзя было быстро и много делать Рефреш токенов, Подписку-Отписку, Лайк-Дизлайк,

// Postgresql Transation - может ли быть такое, что сама команда Rollback не посылается, в этот момент в Бд отключится ли транзакция самостоятельно?
Нужно ли вообще роллбэкать транзакцию в случае возникновения ошибоки от БД в после старта транзакции.
Может ли быть такое, что Роллбэк команда не дойдет до Бд?
ЧТо делать, если имеется ошибка при отправке команды Commit?
Нужно проверять, нет ли открытых транзакций, котрые длятся долгое время, и закрывать.
Как удостовериться, что транзакция точно заверщена или отклонна. Стоит ли закрывать коннекшн после ошибки внутри транзакции, чтобы на стороне бд транзакция точно завершилась
Обработать ошибки Postgresql? для понимания того, что случилось с транзакцией?

FFI-------------------------------------------------------------------------------------------------------------------------------------------
// rust binary ffi optimize for size.  !!!!!!!!!!!!
// https://arusahni.net/blog/2020/03/optimizing-rust-binary-size.html
// https://github.com/johnthagen/min-sized-rust !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
FFI-------------------------------------------------------------------------------------------------------------------------------------------

// Конда меняется любой токен, нужно, чтобы все устройства об этом узнали. Устройства должны быть подписаны на общий Клауд канал, в котором прийдет сообщение "удалить токен у себя из памяти".

// Нужен ТокенБлекЛист (Авторизация, Подписка на канал меняет токен, и старый должен быть в блеклисте.) на Редисе или собственнои отдельном сервере. Либо же сделать блеклист, который дублируется на каждом сервер с основным кодом, и на эти сервера распушивать по Udp протоколу через один основной.
Нужно смотреть места, где Token::encode(). Или там, где удаялется сущность, которая была под токеном (удаение канала)


Сериализатор Биткод для рекуэст-респонс поменять на Rkyv?

сейчас комментарий удаяется как "Удалить,где айди=_ и автор=_", но не идет проверка на автора первым запросом и отдача ошибки. Посмотреть, где еще заменить на такой же паттерн.

https://www.reddit.com/r/rust/comments/85qp50/how_to_disable_logging_for_certain_crates/         disable logging from other crates.


!!!!!!!!!!!!!!!!!11
Нужно, чтобы Удалить можно было только после того, как все токены достигнутсрока экспирации.
ChannelPublication1CommentaryDelayedDeletion_CanBeDeletedFrom - поменять константу после того, как сделаю Токен.
ChannelDelayedDeletion_CanBeDeletedFrom - поменять константу после того.


добавить, is_author(commentary) - и подобные значения, которые позволят уменьшить количество запросов
возможно, добавить channel__access_modifier в channel, так как он проверяется на заборе публикаций


incoming: Self::Incoming<'a>   Почему не incoming: &'a Self::Incoming<'b>
Проблема с определение Лайфтайма компилятором. Попробовать сделать это в edition = 2024.

Может быть, просммотры публикаций создавать прямо во время забора публикаций, а не принимать запрос на Вью. Как на фронте понимать, стоит ли делать запрос на проссмотр, если пользователь листает ленту далеко к меньшей ддате создания?
Нужен механизм, определяющий, просмотрены ли уже публикации. Лучше сделать по максимальной дате забора публикаций.
!!!!!!1 можно view и mark держать в одной таблице - так не теряем производительности.

В енкодинге токенов есть сериализация данных. Может быть, ее сделать просто через lebytes ? Проверить скорость

Убрать Сендед_ и сделать через Арк?

Инкоминге все токены должны передаваться от высшего к текущему. Каждый токен отвечает за свои права.
Айдишники сущности предыдущего токена в видимой части Сигнда иметь не нужно


сделать то, что на стикерах.