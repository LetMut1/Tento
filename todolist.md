// - Ставить капчи на фронтеэнде. Ставить проверки на количество запросов на бэкенде через кеш.

БЭКЕНД бэклог:
// - Postgresql url - посмотреть все параметры.
// Postgresql сделать максимальное время коннекшна. https://www.postgresql.org/docs/current/runtime-config-client.html
// Postgresql политика доступа. В приложении дать права только на чтение и запись.

// core affinity - нужно ли это.

// - TLS, Connection Pool for Lettre.

// - Hyper TCP/HTTp connection pool. Есть ли коннекшн пул Тсп на сервере?

// - Понять, сколько Коннекшноы для Бд должно быть в пуулле в инстансе приложения.

// - При продакшне проверить, везде ли расставлены тлс и нужно ли это

// - При выходе в продакшн поставить защиту от флуда. Чтобы пользователь не мог сделать миллион публикаций, например. То есть, чтобы нам быстро не заполнили террабайты данных.

// - Http3 Quick.

// - При релизе распределить роли в Бд для безопасности.

// - ставить капчи на фронтеэнде. Ставить проверки на количество запросов на бэкенде через кеш.

// - Ограничивать количество запросов с одного адреса на специфические урлы. (Например, отправка писем, и так далее)

// - Ограничить максимальный развмер данных во входящем запросе на апи. (Проверять длину Хедеров, проверять длину Тела)

// - Вопрос. Испоьзуется оптимистичная блокировка, то есть, один процесс в одно время, второй ждет или отменяется?)

// - Attack types (DDOS, for example)

// - Header Connection: Keep-alive - disable https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8/Connection

// - Изучить конфигурации Рсурсов( Postgresql, Redis, ...)

// - Сделать механизм изменения секьюрити кей (самый важное, что будет храниться на сервере) для всех токенов.

// - Там, где убрано On Conflict Do Update для Постгрескл, проверить, как себя поведет код при возникновении нарушения уникальности

// - Подумать, какие поля в базе данных должны быть захешированы (закодированы) и нужно ли это/

// - В миграциях стоит ON DELETE RESTRICT при ForeignKey. Наверное, лучше делать Каскадное удаление. (как вариант, ничего вообще не удалять при удалеии, но помесать, что удалено)

// - Разобратьс с лимитами на сущность для другой сущности. Например, у юзера только 100 каналов подписанных, 300 диалогв, и тд и тп.

// - КАк удалять зваписи из AUDevice и нужно ли?. Те девайсы, которые уже не используются у пользователя. Как отследить, что используется за какой период, а что нет. Добавить параметр и обновлять при обновлении рефрешТокена? или же смотреть сразу в рефрештокене?

// - Проверять, сколько байт принимаем с запроса (Установить порог, чтобы нельзя было сделать переполнение оперативной памяти). Вообще, проверить вот что. Контент-Ленс установить маленький, но послать больше байт. Как http отреагирует вообще. https://docs.rs/hyper/0.14.24/hyper/body/fn.to_bytes.html посмотреть пример

// - Linux socket filtering with BPF нужно ли?

// - В репозитория при Insert без "On Conflict do nothing", Возможно, стоит проверять на количество строк и выдавать логик эрро, о том, что должна быть строка. Это лучше, чем не попасть в индекс в вектора, так как случится паника.

// - Обязательно сделать так, чтобы на каждый НАСТОЯЩИЙ POST (то есть, insert/update в БД) не нужно было проверять на наличие в бд пользователя, айди которого пришел в токене. (В простом варианте пользователя можно удалить, но токен для него останется валидным до экспирации). Нужно придумать механизм, который удаляет пользователя именно из бд ТОЧНО после того, как вышел срок экспирации. Например, помечать пользователя как удаленный, и не давать таким пользователям создавать аксесс токен, но удалять после.

// - Для регистрации добавить много защит. От скриптовой регистрации. От регистрации с одного телефона многих аккаунтов и подобныке ю


// !- ОБНОВИТЬ КРЕЙТЫ перед релизом. Понять, какие фичи нужны и везде ли нужны дефаулт-фичи.

// - проерить, везде ли UTC таймзона?

// СДелать механизм защиты от DDDos на кеше - для каждого апи разное количество допустимых запросов.

// opt-lvl=3 slower opt-level=2 https://doc.rust-lang.org/cargo/reference/profiles.html https://doc.rust-lang.org/rustc/profile-guided-optimization.html

// Проверить, что не нужно заново создавать коннекшн пул (то есть, не нужно заново перезапускать сервер), если Бд отключилась и потом включилась.

// Как синхронизировать время на серверах в распределенной системе? Нужно ли для моих задач (не требуется микроточности).Если нужнн один источник правды, то создать 1 сервер, отдающий время - есть ли смысл?



БЭКЕНД todo:
// Возможно ли не хранить Рефреш токен в Бд? Завязать его на Аксессе?  но как тогда делать разлогин на сервере принудительный?
// Или идти от обратного??? В Бд хранить только те токены, котоыре разлогинились принудительно, потому что принудительный разлогин делают намного меньше людей.
// cs.user__id = ${}   это можно написать в условие On Для JOIN, но можно и написать в условие WHERE. ПОнять, где его нужно написать, чтобы с самого начала в выборке для джоина было меньше строк.
// Регистрация, создание каналов ( и подобное) должно быть сделано через криптограыию ( нужно, чтобы была уверенность  в том, что запрос происходит не ботом, а через приложение с устройства).
// !!!!!!!!!!!! лайки, просмотры класть в другую бд, (Скорее всего Кликхаус) чтобы перезаписывалось меньше информации. Сейчас вся информация о канале будет перезаписываться в строку при изменении ожного лайкаю.
// !!!!!!! reset_password_last_step добавить емейл (посмотреть, подобные кейсы), чтобы проверять соотетсвие емейла и айдишника???????????
// channel_subscription create обработать ALready_subscribed
// В Ресендах_емейла проверять на ВронгЕнтертраесКвантити на всякий случай.

// - Разбить код на микросервисы. Использовать Features, чтобы можно было, например, скомпилировать только работу с каналами, но не с токенами.
// !!!!!!!!!!!!!!! Проверять валидность байт в типе Стринг с клиента. Возможно, встроить в модуль.
// Настроить TCP:
     http2_builder = http2_builder
         .tcp_nodelay(environment_configuration.application_server.tcp.nodelay)
         .tcp_sleep_on_accept_errors(environment_configuration.application_server.tcp.sleep_on_accept_errors)
         .tcp_keepalive_retries(environment_configuration.application_server.tcp.keepalive.retries_quantity);
     http2_builder = match environment_configuration.application_server.tcp.keepalive.duration {
         Option::Some(duration) => http2_builder.tcp_keepalive(Option::Some(Duration::from_secs(duration))),
         Option::None => http2_builder.tcp_keepalive(Option::None),
     };
     http2_builder = match environment_configuration.application_server.tcp.keepalive.interval_duration {
         Option::Some(interval_duration) => http2_builder.tcp_keepalive_interval(Option::Some(Duration::from_secs(interval_duration))),
         Option::None => http2_builder.tcp_keepalive_interval(Option::None),
     };
// Hyper TCP/HTTp connection pool - ?
// Нужно ли вообще вообще все крипто(Encoding) делать в Tokio blocked threads.

// сделать миграции как команду, чтобы можно было запускать из кода и не использовать сторонний сервис по типу Дизеля.
// Серилизация в Bytes сразу возможно ли ?
// проставить инлайнинг
// в Бд различать ConstraintException и недоступность базы данных.

// Составить требования для пароля.

// PostgresqlRepository<ChannelSubscription>::create_1  В подобных местах нужно делать в парадигме апсерта/ Do Nothing?

// Postgresql Transation - может ли быть такое, что сама команда Rollback не посылается, в этот момент в Бд отключится ли транзакция самостоятельно?
Нужно ли вообще роллбэкать транзакцию в случае возникновения ошибоки от БД в после старта транзакции.
Может ли быть такое, что Роллбэк команда не дойдет до Бд?
ЧТо делать, если имеется ошибка при отправке команды Commit?
Нужно проверять, нет ли открытых транзакций, котрые длятся долгое время, и закрывать.
Как удостовериться, что транзакция точно заверщена или отклонна. Стоит ли закрывать коннекшн после ошибки внутри транзакции, чтобы на стороне бд транзакция точно завершилась
Обработать ошибки Postgresql? для понимания того, что случилось с транзакцией?

// TODO FFI-------------------------------------------------------------------------------------------------------------------------------------------
// TODO rust binary ffi optimize for size.  !!!!!!!!!!!!
// https://arusahni.net/blog/2020/03/optimizing-rust-binary-size.html
// https://github.com/johnthagen/min-sized-rust !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// TODO FFI-------------------------------------------------------------------------------------------------------------------------------------------

Сериализатор Биткод для рекуэст-респонс поменять на Rkyv?


сделать так, чтобы нельзя было быстро и много делать Подписку-Отписку, Лайк-Дизлайк,


в бд сохранять created_at в миллисекундах там, на которые стоит уникальный индекс?

нужен ли ChannelPublicationViewingToken - токен, который говорит о том, что юзер подписан. чтобы на каждый запрос на забор публикации не проверять. подписан ли он. Где его выдавать?
Нужен ли токен, который защищает от ботов. есть ли смысл?
!!!!!!!!!!!!!!!!!!! Отдельное апи на запрос токенов доступа к каналам, который живет 10 минут. Так уберем много запросов на проверку возможности предастовления данных



Каналы, на которые подписан юзер, класть в АксессТокен?
Каналы, для которых пользователь является овнером, класть в АксессТокен?


ffi убрать лищние скобки при матчинге прецедентов

При криейтах проставить On conflict on constraint


Все Криэйты, который возвращают айди или подобное, должны возвращать Оптион.
