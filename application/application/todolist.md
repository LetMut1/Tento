ФРОНТЕНД оптимизация:
1) Переиспользованеи коннекшна для http: - ????
То есть, установили несколько коннекшнов, для запросов асинхронно. Затем держим некоторые коннекшны открытыми для последующих запросов, но не слишком долго. То есть, если ситуация уже не предполагает постоянного взаимодействия по коннекшну, его нужно закрыть.
https://stackoverflow.com/questions/58819199/how-to-keep-long-connection-in-http2

БЭКЕНД бэклог:
// TLS, Connection Pool for Lettre.
// При продакшне проверить, везде ли расставлены тлс и нужно ли это
// - При выходе в продакшн поставить защиту от флуда. Чтобы пользователь не мог сделать миллион публикаций, например. То есть, чтобы нам быстро не заполнили террабайты данных.
// - Cейчас нет возможности использовать async trait или реализовать подобное в stable verson without allocation Futures object in heap. Единственный путь для трейтов - написать свой объект фьючера,
// поэтому для архитектуры сейчас используется не имплементация трейтов, а методы, которые принимают функции, отдающие Future.
// Как только в Стэйбл версии появится возможность использовать async trait без потерь, нужно переписать код.
// - Hyper 0.14.0 заменить на Hyper 1.0.0, и внедрить Tls как Фичу, чтобы можно было отключать для нужнд Реверс-прокси.
// - Http3 Quick.
// - При релизе распределить роли в Бд для безопасности.
// - Проверить все алгоритмы хеширования. Пароль, токены.. все. Подобрать оптимальную по длинне Соль или подобный параметр.
// - Подумать, нужно ли где-то защищаться от ddos c помощью Pow
// - Стоит ли у все миграций в Down секции НЕ писать удаление? ТО есть, удалять всегда руками?
// - ставить капчи на фронтеэнде. Ставить проверки на количество запросов на бэкенде через кеш.
// - Найти или написать другое приложение для управления миграциями. Поменять номреа в более логичном порядке или создавать по дате, по классике
// - Ограничивать количество запросов с одного адреса на специфические урлы. (Например, отправка писем, и так далее)
// - Ограничить максимальный развмер данных во входящем запросе на апи. (Проверять длину Хедеров, проверять длину Тела)
// - Вопрос. Испоьзуется оптимистичная блокировка, то есть, один процесс в одно время, второй ждет или отменяется?)
// - Более короткоживужие APUsAcTo для админов разного рода
// - Attack types (DDOS, for example)
// - Header Connection: Keep-alive - disable https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8/Connection
// - Изучить конфигурации Рсурсов( Postgresql, Redis, ...)
// - Сделать механизм изменения секьюрити кей (самый важное, что будет храниться на сервере) для всех токенов.
// - Там, где убрано On Conflict Do Update для Постгрескл, проверить, как себя поведет код при возникновении нарушения уникальности
// - Подумать, какие поля в базе данных должны быть захешированы (закодированы) и нужно ли это/
// - Возможно ли убрать часть логгирования в крейтах (например, сохранение в оперативную память для последующей записи в лог) из этих крейтов, то есть, выключить лог внутри крейтов.
// - В миграциях стоит ON DELETE RESTRICT при ForeignKey. Наверное, лучше делать Каскадное удаление. (как вариант, ничего вообще не удалять при удалеии, но помесать, что удалено)
// - "// TODO  TRANZACTION" Постаивть транзакции и посмотреть, что возвращает каждый метод, который есть внутри транзакций.
// - Разобратьс с лимитами на сущность для другой сущности. Например, у юзера только 100 каналов подписанных, 300 диалогв, и тд и тп.
// - КАк удалять зваписи из AUDevice и нужно ли?. Те девайсы, которые уже не используются у пользователя. Как отследить, что используется за какой период, а что нет. Добавить параметр и обновлять при обновлении рефрешТокена? или же смотреть сразу в рефрештокене?
// - Может быть, расставить Дропы для конекшенов, чтобы они уходили в пул сразу, как только становятся не нужны?
// - Проверять, сколько байт принимаем с запроса (Установить порог, чтобы нельзя было сделать переполнение оперативной памяти). Вообще, проверить вот что. Контент-Ленс установить маленький, но послать больше байт. Как http отреагирует вообще. https://docs.rs/hyper/0.14.24/hyper/body/fn.to_bytes.html посмотреть пример
// - Linux socket filtering with BPF нужно ли?
// - В репозитория при Insert без "On Conflict do nothing", Возможно, стоит проверять на количество строк и выдавать логик эрро, о том, что должна быть строка. Это лучше, чем не попасть в индекс в вектора, так как случится паника.
// - Обязательно сделать так, чтобы на каждый НАСТОЯЩИЙ POST (то есть, insert/update в БД) не нужно было проверять на наличие в бд пользователя, айди которого пришел в токене. (В простом варианте пользователя можно удалить, но токен для него останется валидным до экспирации). Нужно придумать механизм, который удаляет пользователя именно из бд ТОЧНО после того, как вышел срок экспирации. Например, помечать пользователя как удаленный, и не давать таким пользователям создавать аксесс токен, но удалять после.
// - Для регистрации добавить много защит. От скриптовой регистрации. От регистрации с одного телефона многих аккаунтов и подобныке ю
// - Возможно, хранить картинки для каналов не под конкретными полями в структуру, а в одном векторе, чтобы можно было бы легче изменять архитектуру. 0 каринка - это аватарка, 1 - это фон - так далее.
// - При новом входе в аккаунт пользователя, если он онлайн на каком-то устройстве, то слать сообщение туда с подстверждением того, согласен ли он на вход с нового устройства или же его взламывкают.
// !- ОБНОВИТЬ КРЕЙТЫ перед релизом. Понять, какие фичи нужны и везде ли нужны дефаулт-фичи.
// - ОПТИМИЗАЦИЯ РАБОТЫ С КЕШЕМ НА КЛИЕНТЕ: В таблице держать столбец - хеш изменений, из которого будет будет понятно, что именно изменилось, и передавать его всегда, чтобы фронт определял, стоит ле перезапрашивать данные
// !- Все лайфтаймы для Fn/FnOnce/FnMut, в сигнатуре которых есть лайфтаймы, должны быть объявлены через HRTB (for<'a>), если обратного не требует конкретный случай.
// Сейчас есть баг https://github.com/rust-lang/rust/issues/102211#issuecomment-1513931928 , но, скорее всего, его уже скоро закроют.
// - проерить, везде ли UTC таймзона?
// - ! Для Кэша использовать https://crates.io/crates/lru .
// СДелать механизм защиты от DDDos на кеше - для каждого апи разное количество допустимых запросов.
// UUID v6/7 - последоватльеный алфавит. Стоит ли заменить в БД sequental integer?
// opt-lvl=3 slower opt-level=2 https://doc.rust-lang.org/cargo/reference/profiles.html https://doc.rust-lang.org/rustc/profile-guided-optimization.html

БЭКЕНД todo:
// Возможно ли не хранить Рефреш токен в Бд? Завязать его на Аксессе?  но как тогда делать разлогин на сервере принудительный?
// Или идти от обратного??? В Бд хранить только те токены, котоыре разлогинились принудительно, потому что принудительный разлогин делают намного меньше людей.
// cs.application_user__id = ${}   это можно написать в условие On Для JOIN, но можно и написать в условие WHERE. ПОнять, где его нужно написать, чтобы с самого начала в выборке для джоина было меньше строк.
// Регистрация, создание каналов ( и подобное) должно быть сделано через криптограыию ( нужно, чтобы была уверенность  в том, что запрос происходит не ботом, а через приложение с устройства).
// Убрать RETURNING из репозитория там, где не нужно ничего возаращать.
// УБрать препэред стейтмент в репозитории там, где все параметры - это числа.
// !!!!!!!!!!!! лайки, просмотры класть в другую бд, (Скорее всего Кликхаус) чтобы перезаписывалось меньше информации. Сейчас вся информация о канале будет перезаписываться в строку при изменении ожного лайкаю.
// Пройтись по всем сущностяи и сделать генерацию времени из кода, если это время по логике не нужно генерировать внутри бд. То есть, CreatedAt и подобных
// !!!!!!! reset_password_last_step добавить емейл (посмотреть, подобные кейсы), чтобы проверять соотетсвие емейла и айдишника???????????
// channel_subscription create обработать ALready_subscribed
// В Ресендах_емейла проверять на ВронгЕнтертраесКвантити на всякий случай.
// impl Resolver<DateTime> {  -> как-то еще через UnixTime тип инфраструктуры.
// - Разбить код на микросервисы. Использовать Features, чтобы можно было, например, скомпилировать только работу с каналами, но не с токенами.
// !!!!!!!!!!!!!!! Проверять валидность байт в типе Стринг с клиента. Возможно, встроить в модуль.
// Коннекшн в методы репозитериев как конкретный зерокост-тип, относящийся к БД.
// СДелал оптимизацию запросов для:
// - application_user_authorization. // ToDo ДОделать остальные. и сделать репозиторий по новым правилам.
// Настроить TCP:
     http2_builder = http2_builder
         .tcp_nodelay(environment_configuration.application_server.tcp.nodelay)
         .tcp_sleep_on_accept_errors(environment_configuration.application_server.tcp.sleep_on_accept_errors)
         .tcp_keepalive_retries(environment_configuration.application_server.tcp.keepalive.retries_quantity);
     http2_builder = match environment_configuration.application_server.tcp.keepalive.duration {
         Some(duration) => http2_builder.tcp_keepalive(Some(Duration::from_secs(duration))),
         None => http2_builder.tcp_keepalive(None),
     };
     http2_builder = match environment_configuration.application_server.tcp.keepalive.interval_duration {
         Some(interval_duration) => http2_builder.tcp_keepalive_interval(Some(Duration::from_secs(interval_duration))),
         None => http2_builder.tcp_keepalive_interval(None),
     };
// Hyper TCP/HTTp connection pool - ?



 Postgres индексы ставить на ловеркейс там, где надо.

сделать миграции как команду, чтобы можно было запускать из кода и не использовать сторонний сервис по типу Дизеля.



убрать data-control-type и вставить типы в конкретные сервисы, где они и используются впервые по цепочке.





Rust 2024 - edition. Поменять, как только выйдет.



base64 - нужен ли? он нужен для кодирования байт в текст, а мы будет все передавать в байтах.



Серилизация в Bytes сразу возможно ли ?


Сериалазер, енкодер, ФОрмРезолвер - сделать более оинаковые имена.


Проверить, что все крипто делается в blocked threads




unsafe { ... } - В многострочие, проверить, как fmt будет реагировать.
