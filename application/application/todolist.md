cargo run --features=manual_testing --bin=core -- --environment_configuration_file_directory=/_tento/application/application/ run_server




ФРОНТЕНД оптимизация:
// Переиспользованеи коннекшна для http: - ????
То есть, установили несколько коннекшнов, для запросов асинхронно. Затем держим некоторые коннекшны открытыми для последующих запросов, но не слишком долго. То есть, если ситуация уже не предполагает постоянного взаимодействия по коннекшну, его нужно закрыть.
https://stackoverflow.com/questions/58819199/how-to-keep-long-connection-in-http2
// - ставить капчи на фронтеэнде. Ставить проверки на количество запросов на бэкенде через кеш.

БЭКЕНД бэклог:
// TLS, Connection Pool for Lettre.
// При продакшне проверить, везде ли расставлены тлс и нужно ли это
// - При выходе в продакшн поставить защиту от флуда. Чтобы пользователь не мог сделать миллион публикаций, например. То есть, чтобы нам быстро не заполнили террабайты данных.
// - Http3 Quick.
// - При релизе распределить роли в Бд для безопасности.
// - Проверить все алгоритмы хеширования. Пароль, токены.. все. Подобрать оптимальную по длинне Соль или подобный параметр.
// - Подумать, нужно ли где-то защищаться от ddos c помощью Pow
// - ставить капчи на фронтеэнде. Ставить проверки на количество запросов на бэкенде через кеш.
// - Ограничивать количество запросов с одного адреса на специфические урлы. (Например, отправка писем, и так далее)
// - Ограничить максимальный развмер данных во входящем запросе на апи. (Проверять длину Хедеров, проверять длину Тела)
// - Вопрос. Испоьзуется оптимистичная блокировка, то есть, один процесс в одно время, второй ждет или отменяется?)
// - Более короткоживужие APUsAcTo для админов разного рода
// - Attack types (DDOS, for example)
// - Header Connection: Keep-alive - disable https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8/Connection
// - Изучить конфигурации Рсурсов( Postgresql, Redis, ...)
// - Сделать механизм изменения секьюрити кей (самый важное, что будет храниться на сервере) для всех токенов.
// - Там, где убрано On Conflict Do Update для Постгрескл, проверить, как себя поведет код при возникновении нарушения уникальности
// - Подумать, какие поля в базе данных должны быть захешированы (закодированы) и нужно ли это/
// - В миграциях стоит ON DELETE RESTRICT при ForeignKey. Наверное, лучше делать Каскадное удаление. (как вариант, ничего вообще не удалять при удалеии, но помесать, что удалено)
// - "// TODO  TRANZACTION" Постаивть транзакции и посмотреть, что возвращает каждый метод, который есть внутри транзакций.
// - Разобратьс с лимитами на сущность для другой сущности. Например, у юзера только 100 каналов подписанных, 300 диалогв, и тд и тп.
// - КАк удалять зваписи из AUDevice и нужно ли?. Те девайсы, которые уже не используются у пользователя. Как отследить, что используется за какой период, а что нет. Добавить параметр и обновлять при обновлении рефрешТокена? или же смотреть сразу в рефрештокене?
// - Проверять, сколько байт принимаем с запроса (Установить порог, чтобы нельзя было сделать переполнение оперативной памяти). Вообще, проверить вот что. Контент-Ленс установить маленький, но послать больше байт. Как http отреагирует вообще. https://docs.rs/hyper/0.14.24/hyper/body/fn.to_bytes.html посмотреть пример
// - Linux socket filtering with BPF нужно ли?
// - В репозитория при Insert без "On Conflict do nothing", Возможно, стоит проверять на количество строк и выдавать логик эрро, о том, что должна быть строка. Это лучше, чем не попасть в индекс в вектора, так как случится паника.
// - Обязательно сделать так, чтобы на каждый НАСТОЯЩИЙ POST (то есть, insert/update в БД) не нужно было проверять на наличие в бд пользователя, айди которого пришел в токене. (В простом варианте пользователя можно удалить, но токен для него останется валидным до экспирации). Нужно придумать механизм, который удаляет пользователя именно из бд ТОЧНО после того, как вышел срок экспирации. Например, помечать пользователя как удаленный, и не давать таким пользователям создавать аксесс токен, но удалять после.
// - Для регистрации добавить много защит. От скриптовой регистрации. От регистрации с одного телефона многих аккаунтов и подобныке ю
// - Возможно, хранить картинки для каналов не под конкретными полями в структуру, а в одном векторе, чтобы можно было бы легче изменять архитектуру. 0 каринка - это аватарка, 1 - это фон - так далее.
// - При новом входе в аккаунт пользователя, если он онлайн на каком-то устройстве, то слать сообщение туда с подстверждением того, согласен ли он на вход с нового устройства или же его взламывкают.
// !- ОБНОВИТЬ КРЕЙТЫ перед релизом. Понять, какие фичи нужны и везде ли нужны дефаулт-фичи.
// - ОПТИМИЗАЦИЯ РАБОТЫ С КЕШЕМ НА КЛИЕНТЕ: В таблице держать столбец - хеш изменений, из которого будет будет понятно, что именно изменилось, и передавать его всегда, чтобы фронт определял, стоит ле перезапрашивать данные
// !- Все лайфтаймы для Fn/FnOnce/FnMut, в сигнатуре которых есть лайфтаймы, должны быть объявлены через HRTB (for<'a>), если обратного не требует конкретный случай.
// Сейчас есть баг https://github.com/rust-lang/rust/issues/102211#issuecomment-1513931928 , но, скорее всего, его уже скоро закроют.
// - проерить, везде ли UTC таймзона?
// - ! Для Кэша использовать https://crates.io/crates/lru .
// СДелать механизм защиты от DDDos на кеше - для каждого апи разное количество допустимых запросов.
// UUID v6/7 - последоватльеный алфавит. Стоит ли заменить в БД sequental integer?
// opt-lvl=3 slower opt-level=2 https://doc.rust-lang.org/cargo/reference/profiles.html https://doc.rust-lang.org/rustc/profile-guided-optimization.html
// Проверить, что не нужно заново создавать коннекшн пул (то есть, не нужно заново перезапускать сервер), если Бд отключилась и потом включилась.

БЭКЕНД todo:
// Возможно ли не хранить Рефреш токен в Бд? Завязать его на Аксессе?  но как тогда делать разлогин на сервере принудительный?
// Или идти от обратного??? В Бд хранить только те токены, котоыре разлогинились принудительно, потому что принудительный разлогин делают намного меньше людей.
// cs.application_user__id = ${}   это можно написать в условие On Для JOIN, но можно и написать в условие WHERE. ПОнять, где его нужно написать, чтобы с самого начала в выборке для джоина было меньше строк.
// Регистрация, создание каналов ( и подобное) должно быть сделано через криптограыию ( нужно, чтобы была уверенность  в том, что запрос происходит не ботом, а через приложение с устройства).
// Убрать RETURNING из репозитория там, где не нужно ничего возаращать.
// УБрать препэред стейтмент в репозитории там, где все параметры - это числа.
// !!!!!!!!!!!! лайки, просмотры класть в другую бд, (Скорее всего Кликхаус) чтобы перезаписывалось меньше информации. Сейчас вся информация о канале будет перезаписываться в строку при изменении ожного лайкаю.
// Пройтись по всем сущностяи и сделать генерацию времени из кода, если это время по логике не нужно генерировать внутри бд. То есть, CreatedAt и подобных
// !!!!!!! reset_password_last_step добавить емейл (посмотреть, подобные кейсы), чтобы проверять соотетсвие емейла и айдишника???????????
// channel_subscription create обработать ALready_subscribed
// В Ресендах_емейла проверять на ВронгЕнтертраесКвантити на всякий случай.

// - Разбить код на микросервисы. Использовать Features, чтобы можно было, например, скомпилировать только работу с каналами, но не с токенами.
// !!!!!!!!!!!!!!! Проверять валидность байт в типе Стринг с клиента. Возможно, встроить в модуль.
// СДелал оптимизацию запросов для:
// - application_user_authorization. // ToDo ДОделать остальные. и сделать репозиторий по новым правилам.
// Настроить TCP:
     http2_builder = http2_builder
         .tcp_nodelay(environment_configuration.application_server.tcp.nodelay)
         .tcp_sleep_on_accept_errors(environment_configuration.application_server.tcp.sleep_on_accept_errors)
         .tcp_keepalive_retries(environment_configuration.application_server.tcp.keepalive.retries_quantity);
     http2_builder = match environment_configuration.application_server.tcp.keepalive.duration {
         Option::Some(duration) => http2_builder.tcp_keepalive(Option::Some(Duration::from_secs(duration))),
         Option::None => http2_builder.tcp_keepalive(Option::None),
     };
     http2_builder = match environment_configuration.application_server.tcp.keepalive.interval_duration {
         Option::Some(interval_duration) => http2_builder.tcp_keepalive_interval(Option::Some(Duration::from_secs(interval_duration))),
         Option::None => http2_builder.tcp_keepalive_interval(Option::None),
     };
// Hyper TCP/HTTp connection pool - ?
// Нужно ли вообще вообще все крипто(Encoding) делать в Tokio blocked threads.
// Postgres индексы ставить на ловеркейс там, где надо.
// сделать миграции как команду, чтобы можно было запускать из кода и не использовать сторонний сервис по типу Дизеля.
// Rust 2024 - edition. Поменять, как только выйдет.
// Серилизация в Bytes сразу возможно ли ?
// проставить инлайнинг
// в Бд различать ConstraintException и недоступность базы данных.
